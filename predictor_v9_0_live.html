<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ðŸŽ¯ Saeed Wingo AI Predictor v9.0 (AWP Ultra-Precision)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
<style>
/* --- Core Modern Glow UI --- */
:root{
  --bg:#050507; --fg:#e6fffb; --muted:#9fdedc; --neon:#38e6ff; --green:#00f59b; --danger:#ff6b6b;
  --warn:#ffc107;
}
*{box-sizing:border-box;font-family:Inter,system-ui,Arial,Helvetica,sans-serif}
html,body{height:100%;margin:0;background:radial-gradient(circle at 20% 10%, #071018 0%, #020204 50%, #000 100%);color:var(--fg)}
.container{max-width:1100px;margin:18px auto;padding:16px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03)}
.header{display:flex;justify-content:space-between;align-items:center;gap:12px}
.title{font-size:1.4rem;font-weight:800;color:var(--neon); text-shadow: 0 0 8px rgba(56, 230, 255, 0.4);}
.subtitle{font-size:0.86rem;color:var(--muted)}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
.btn{padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);background:rgba(0,0,0,0.5);color:var(--fg);font-weight:700;cursor:pointer;transition:all 0.2s;}
.btn:hover{background:rgba(255,255,255,0.1);}
.btn.primary{background:linear-gradient(90deg,var(--neon),var(--green));color:#001b1a;border:none}
.btn.primary:hover{box-shadow: 0 0 10px rgba(56, 230, 255, 0.6);}
.btn.warn{background:linear-gradient(90deg,#ff61c7,var(--danger));color:white;border:none}
.grid{display:grid;grid-template-columns:2fr 1fr;gap:14px;margin-top:14px}
.panel{padding:12px;border-radius:10px;background:rgba(0,0,0,0.45);border:1px solid rgba(255,255,255,0.02)}
textarea{width:100%;min-height:120px;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:rgba(0,0,0,0.55);color:var(--fg);resize:vertical}
.input-row{display:flex;gap:8px;align-items:center;margin-top:8px}
.input-row input[type=number]{padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:var(--fg);width:140px;text-align:center}
.small{font-size:0.86rem;color:var(--muted)}
.stat-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px}
.stat{padding:8px;border-radius:8px;background:rgba(0,0,0,0.45);border:1px solid rgba(255,255,255,0.02);font-weight:700;color:var(--muted)}
.history{max-height:480px;overflow-y:auto;margin-top:10px;border-top:1px dashed rgba(255,255,255,0.02);padding-top:8px}
.hist-item{display:flex;gap:8px;align-items:center;padding:8px;border-bottom:1px dashed rgba(255,255,255,0.02)}
.h-round{width:48px;color:var(--neon);font-weight:800}
.h-act{width:40px}
.h-pred{flex:1;color:var(--muted)}
.footer-note{margin-top:8px;color:var(--muted);font-size:0.86rem}
.toggle{display:flex;align-items:center;gap:8px}
/* --- Custom Colors for Results & Stages --- */
.bad{color:#ff61c7}
.success{color:var(--green);font-weight:700;}
.fail{color:var(--danger);font-weight:700;}
.stage-0, .stage-1{color:var(--green); font-weight: 800;}
.stage-2, .stage-3{color:var(--neon); font-weight: 800;}
.stage-4-plus{color:var(--danger); font-weight: 800; text-shadow: 0 0 5px rgba(255, 107, 107, 0.4);}

@media (max-width:980px){ .grid{grid-template-columns:1fr} .input-row{flex-direction:column;align-items:stretch} }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div>
      <div class="title">ðŸŽ¯ Saeed Wingo AI Predictor v9.0 (AWP Ultra-Precision)</div>
      <div class="subtitle">Aggressive Weighted Prediction (AWP) Â· Under-3 Winning Focus Â· Hybrid L3â€“L9 Deep Patterns</div>
    </div>
    <div class="controls">
      <div id="userArea" class="small">Not signed in</div>
      <button id="googleSignIn" class="btn primary">Sign in with Google</button>
      <button id="downloadHtml" class="btn">Download HTML</button>
      <button id="exportRawBtn" class="btn warn">Export Raw Data</button>
      <button id="importFileBtn" class="btn">Import File</button>
      <input type="file" id="importFileInput" style="display: none;" accept=".txt,.csv">
      <button id="exportFullBtn" class="btn">Export Full History</button>
      <button id="clearLocal" class="btn warn">Clear All</button>
      <button id="saveLocal" class="btn">Save Local</button>
    </div>
  </div>

  <div class="grid">
    <div>
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:800">Live Training & Import</div>
          <div class="small">Pattern depth: <span id="patternLenDisplay">L3 to L9</span></div>
        </div>

        <p class="small footer-note">Paste comma-separated numbers (0â€“9) or space/newline separated. <span class="success">Actual numbers auto-append here.</span></p>
        <textarea id="importArea" placeholder="Paste sequence here (commas, spaces or newlines allowed)"></textarea>
        <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
          <button id="runTrain" class="btn primary">Run / Batch Merge Train</button>
          <button id="analyzeBtn" class="btn">Analyze Memory</button>
          <div id="status" class="small" style="margin-left:8px">Status: idle</div>
        </div>

        <div class="panel" style="margin-top:12px">
          <div style="display:flex;gap:10px;align-items:center">
            <div style="flex:1">
              <div class="small">Predicted Digit</div>
              <div id="predDigit" style="font-size:1.4rem;font-weight:800">-</div>
            </div>
            <div style="flex:1">
              <div class="small">Predicted Color</div>
              <div id="predColor" style="font-size:1.1rem;font-weight:800">-</div>
            </div>
            <div style="flex:1">
              <div class="small">Predicted B/S</div>
              <div id="predBS" style="font-size:1.1rem;font-weight:800">-</div>
            </div>
            <div style="flex:2">
              <div class="small">Confidence</div>
              <div style="height:12px;background:#222;border-radius:8px;overflow:hidden"><div id="confFill" style="height:12px;width:0%;background:linear-gradient(90deg,var(--neon),var(--green));transition:width:300ms"></div></div>
              <div id="confText" class="small footer-note">â€”</div>
            </div>
          </div>

          <div style="margin-top:12px;display:flex;justify-content:space-between;align-items:center;gap:12px">
            <div style="flex:1">
              <div class="input-row">
                <input id="manualInput" type="number" min="0" max="9" placeholder="Enter actual number (0-9)">
                <button id="enterBtn" class="btn primary">Submit</button>
              </div>
              <div class="small footer-note">Auto-clear input on submit âœ” â€” Input will be focused automatically</div>
            </div>

            <div style="width:280px">
              <div style="display:flex;gap:8px;align-items:center">
                <label class="toggle"><input type="checkbox" id="aggressiveAWP"> <span class="small" style="color:var(--neon); font-weight:700;">AWP Mode (Under-3 Aggression) ðŸŽ¯</span></label>
              </div>
              <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
                <label class="toggle"><input type="checkbox" id="colorOnlyFocus"> <span class="small">Color Only Prediction Focus</span></label>
              </div>
              <div class="note small footer-note">AWP Mode: Uses Deep Patterns (L6-L9) to find high-conf bets in Stage 2/3.</div>
            </div>
          </div>
        </div>

      </div>

      <div class="panel" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:800">Pattern Memory Overview</div>
          <div class="small">Unique patterns: <span id="uniquePatterns">0</span></div>
        </div>
        <div id="topPatterns" style="margin-top:8px" class="small"></div>
      </div>
    </div>

    <div>
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:800">Stats & Recent History</div>
          <div class="small">Rounds: <span id="totalRounds">0</span></div>
        </div>

        <div class="stat-grid">
          <div class="stat">Big/Small W/L <span class="val" id="bsWL">0 / 0</span></div>
          <div class="stat">Color W/L <span class="val" id="colorWL">0 / 0</span></div>
          <div class="stat">BS Loss Stage <span class="val" id="bsStage">0</span></div>
          <div class="stat">Color Loss Stage <span class="val" id="colStage">0</span></div>
        </div>

        <div class="history" id="historyList"></div>
        <div class="footer-note">Last 150 rounds shown. Use Export Full History for full CSV.</div>
      </div>
    </div>
  </div>
</div>

<script type="module">
/* --- AWP ULTRA-PRECISION v9.0 ---
   1. CORE LOGIC: Aggressive Weighted Prediction (AWP) implemented in getFinalPrediction.
   2. PATTERN DEPTH: Pattern recording/lookbacks extended from L1 up to L9 for deep analysis.
   3. STABILITY: AWP Mode enforces high-conf bets in Stage 2/3 using deep patterns (L6-L9).
   4. UI: Toggles updated to 'aggressiveAWP' and 'colorOnlyFocus'.
   5. Local Keys updated to v9_0.
*/

// --- Firebase Configuration (Unchanged) ---
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
import { getFirestore, doc, setDoc, getDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

const firebaseConfig = {
  // --- USER'S CORRECT KEYS ---
  apiKey: "AIzaSyA6uJKnUfJqS1T_GbSlUq8eChxJBdZtwVQ",
  authDomain: "saeed-hybrid-predictor-672ed.firebaseapp.com",
  projectId: "saeed-hybrid-predictor-672ed",
  storageBucket: "saeed-hybrid-predictor-672ed.firebasestorage.app",
  messagingSenderId: "968218548586",
  appId: "1:968218548586:web:c51840d9c49225f885ad13",
  measurementId: "G-QBK0HPDDBE"
  // --- END OF USER'S CORRECT KEYS ---
};

let app = null;
try { app = initializeApp(firebaseConfig); } catch(e){ console.warn("Firebase init failed:", e.message); }

const auth = app ? getAuth(app) : null;
const provider = new GoogleAuthProvider();
const db = app ? getFirestore(app) : null;

// ---------- DOM & State (Unchanged) ----------
const importArea = document.getElementById('importArea');
const runTrainBtn = document.getElementById('runTrain');
const analyzeBtn = document.getElementById('analyzeBtn');
const statusEl = document.getElementById('status');
const predDigitEl = document.getElementById('predDigit');
const predColorEl = document.getElementById('predColor');
const predBSEl = document.getElementById('predBS');
const confFill = document.getElementById('confFill');
const confText = document.getElementById('confText');
const historyList = document.getElementById('historyList');
const totalRoundsEl = document.getElementById('totalRounds');
const uniquePatternsEl = document.getElementById('uniquePatterns');
const topPatternsEl = document.getElementById('topPatterns');
const enterBtn = document.getElementById('enterBtn');
const manualInput = document.getElementById('manualInput');
// NEW TOGGLES FOR V9.0
const aggressiveAWPToggle = document.getElementById('aggressiveAWP');
const colorOnlyFocusToggle = document.getElementById('colorOnlyFocus');
const googleSignInBtn = document.getElementById('googleSignIn');
const userArea = document.getElementById('userArea');
const saveLocalBtn = document.getElementById('saveLocal');
const exportFullBtn = document.getElementById('exportFullBtn');
const exportRawBtn = document.getElementById('exportRawBtn');
const clearLocalBtn = document.getElementById('clearLocal');
const downloadHtmlBtn = document.getElementById('downloadHtml');
const importFileBtn = document.getElementById('importFileBtn');
const importFileInput = document.getElementById('importFileInput');

const PATTERN_LEN = 3;
const MAX_PATTERN_DEPTH = 9; // L1 up to L9

// LOCAL KEYS UPDATED TO V9_0
const LOCAL_KEY = 'saeed_hybrid_v9_0_state'; 
const RAW_DATA_KEY = 'saeed_hybrid_v9_raw_data';
const PATTERNS_KEY_LARGE = 'saeed_patterns_v9_large';
const HISTORY_KEY_LARGE = 'saeed_history_v9_large';

let state = { history: [], patterns: {}, aggressiveAWP: false, colorOnlyFocus: false };
let currentUser = null;
let unsubscribeCloud = null;

// ---------- Helpers (MODIFIED saveLocal/loadLocal - Simplified Toggles) ----------
function setStatus(txt, ok=false){ statusEl.textContent = 'Status: ' + txt; statusEl.style.color = ok ? 'var(--green)' : ''; }

// --- ROBUST saveLocal ---
function saveLocal(){ 
    // Essential settings sirf is key mein save honge
    const essentialState = { 
        aggressiveAWP: aggressiveAWPToggle.checked, 
        colorOnlyFocus: colorOnlyFocusToggle.checked,
    };
    
    // Large data ko stringify karke alag keys mein save karne ki koshish
    const patternsToSave = JSON.stringify(state.patterns);
    const historyToSave = JSON.stringify(state.history);

    try{ 
        // 1. Save small essential settings first
        localStorage.setItem(LOCAL_KEY, JSON.stringify(essentialState)); 
        
        // 2. Try to save large patterns memory
        localStorage.setItem(PATTERNS_KEY_LARGE, patternsToSave);
        
        // 3. Try to save history
        localStorage.setItem(HISTORY_KEY_LARGE, historyToSave);

        setStatus('Saved locally (Settings, Patterns, History)', true);
    }catch(e){
        if (e.name === 'QuotaExceededError' || e.code === 22) {
            setStatus('âš ï¸ Local Save FAILED: Patterns Memory is TOO BIG! Only Settings Saved. Use Cloud Sync!', false);
            console.error("Local Storage Quota Exceeded. Patterns/History too large. Use Cloud.", e);
        } else {
            console.error(e); 
            setStatus('Local save failed', false);
        }
    } 
}

// --- ROBUST loadLocal ---
function loadLocal(){ 
    // 1. Load Essential Settings
    const s = localStorage.getItem(LOCAL_KEY); 
    if(s){ 
        try{ 
            const d = JSON.parse(s); 
            state.aggressiveAWP = !!d.aggressiveAWP; 
            state.colorOnlyFocus = !!d.colorOnlyFocus; 
        }catch(e){console.error('parse local', e);} 
    } 

    // 2. Load Patterns and History from separate large keys
    const rawPatterns = localStorage.getItem(PATTERNS_KEY_LARGE);
    const rawHistory = localStorage.getItem(HISTORY_KEY_LARGE);
    
    if (rawPatterns) {
        try { state.patterns = JSON.parse(rawPatterns); } catch(e) { console.error("Patterns load failed", e); }
    }
    if (rawHistory) {
        try { state.history = JSON.parse(rawHistory); } catch(e) { console.error("History load failed", e); }
    }

    aggressiveAWPToggle.checked = !!state.aggressiveAWP; 
    colorOnlyFocusToggle.checked = !!state.colorOnlyFocus; 

    // 3. Load Raw Data
    const rawData = localStorage.getItem(RAW_DATA_KEY);
    if (rawData) {
        importArea.value = rawData;
        setStatus('Raw data loaded to box', true);
    }
    renderAll(); 
}
function saveRawDataToLocal(){
    try{ localStorage.setItem(RAW_DATA_KEY, importArea.value.trim()); } catch(e){ console.error('Raw data save failed', e); }
}

function keyFromSeq(seq){ return seq.join('-'); }
function recordPattern(key,next){
  if(!state.patterns[key]) state.patterns[key] = { counts: {}, total: 0 };
  const p = state.patterns[key];
  p.counts[next] = (p.counts[next] || 0) + 1;
  p.total += 1;
}
function bestFromPattern(key){
  const p = state.patterns[key]; if(!p) return null;
  let best = null; for(const [d,c] of Object.entries(p.counts)) if(!best || c > best.count) best = { digit: Number(d), count: c };
  if(!best) return null;
  const conf = Math.round((best.count / p.total) * 100);
  return { digit: best.digit, count: best.count, total: p.total, confidence: conf };
}

function mapDigit(d){
  d = Number(d);
  const map = {
    0:{Color:'Red', BS:'Small'}, 1:{Color:'Green', BS:'Small'}, 
    2:{Color:'Red', BS:'Small'}, 3:{Color:'Green', BS:'Small'}, 
    4:{Color:'Red', BS:'Small'}, 5:{Color:'Green', BS:'Big'}, 
    6:{Color:'Red', BS:'Big'}, 7:{Color:'Green', BS:'Big'}, 
    8:{Color:'Red', BS:'Big'}, 9:{Color:'Green', BS:'Big'}
  };
  return map[d] || {Color:'N/A', BS:'N/A'};
}

function parseSequenceText(text){
  if(!text) return [];
  const parts = text.split(/[\s,]+/); 
  const nums = parts.map(s=>s.trim()).filter(s=>s.length>0).map(s=>Number(s)).filter(n=>!isNaN(n) && n>=0 && n<=9);
  return nums;
}

function weightedPrediction(lookbacks){
  const candidates = {}; let hasPattern = false;
  for(let i=0;i<lookbacks.length;i++){
    const seq = lookbacks[i], key = keyFromSeq(seq), best = bestFromPattern(key);
    if(!best) continue;
    hasPattern = true;
    // Weights based on pattern length: L9=5, L8=5, L7=4, L6=4, L5=3, L4=3, L3=3, L2=2, L1=1. 
    // Higher depth patterns get more weight for better precision.
    const len = seq.length;
    let weight = 1;
    if(len >= 8) weight = 5;
    else if(len >= 6) weight = 4;
    else if(len >= 3) weight = 3;
    else if(len === 2) weight = 2;
    
    const d = best.digit, score = best.confidence * weight;
    if(!candidates[d]) candidates[d] = { score: 0, weightSum: 0 };
    candidates[d].score += score; candidates[d].weightSum += weight;
  }
  if(!hasPattern) return null;
  let chosen = null, chosenScore = 0;
  for(const [d,info] of Object.entries(candidates)){
    if(!chosen || info.score > chosenScore){ chosen = Number(d); chosenScore = info.score; }
  }
  const totalWeights = Object.values(candidates).reduce((s,i)=>s + i.weightSum,0) || 1;
  let conf = Math.round((chosenScore / (100 * totalWeights)) * 100);
  conf = Math.min(100, Math.max(5, conf));
  const mapped = mapDigit(chosen);
  return { predictedDigit: chosen, predictedColor: mapped.Color, predictedBS: mapped.BS, confidence: conf };
}

// L1 to L9 Hybrid lookbacks
function predictFromArray(arr, index){
  if(index < 1) return null;
  const lookbacks = [];
  
  for(let i = 1; i <= MAX_PATTERN_DEPTH; i++){
      if(index >= i) {
          lookbacks.push(arr.slice(index - i, index));
      }
  }

  return weightedPrediction(lookbacks);
}

// Main prediction using memory
function predictUsingMemory(){
  const h = state.history;
  if(!h || h.length < 1) return null;
  const actuals = h.map(r => r.Actual); 
  const lookbacks = [];
  
  for(let i = 1; i <= MAX_PATTERN_DEPTH; i++){
      if(actuals.length >= i) {
          lookbacks.push(actuals.slice(-i));
      }
  }

  return weightedPrediction(lookbacks);
}

// --- CORE V9.0 AGGRESSIVE WEIGHTED PREDICTION (AWP) LOGIC ---
function getFinalPrediction(rawPred, bsStage, colStage){
    if(!rawPred) return null;
    const confidence = rawPred.confidence;
    const currentStage = Math.max(bsStage, colStage); 

    let finalPred = rawPred;

    if(aggressiveAWPToggle.checked){
        // AWP Mode: Aggressively try to win under Stage 3
        if (currentStage === 0 || currentStage === 1) {
            // Stage 0 & 1: Conservative Bet
            if (confidence < 75) { 
                finalPred = null; 
                finalPred.skipReason = 'HOLD (Safe zone low conf)';
            }
        } else if (currentStage === 2) {
            // Stage 2: Aggressive Analysis (AWP Threshold)
            if (confidence < 60) { 
                finalPred = null; 
                finalPred.skipReason = 'HOLD (AWP: Stage 2 - Conf < 60)';
            }
        } else if (currentStage === 3) {
            // Stage 3: Critical Analysis (AWP Threshold)
            if (confidence < 50) { 
                finalPred = null; 
                finalPred.skipReason = 'HOLD (AWP: Stage 3 - Conf < 50)';
            }
        } else if (currentStage >= 4) {
            // Stage 4+: Recovery Mode (AWP Threshold)
            if (confidence < 55) { 
                finalPred = null; 
                finalPred.skipReason = 'HOLD (AWP: Recovery Low Conf)';
            }
        }
    } else {
        // Standard (AWP OFF) Mode: Simple 60% threshold 
         if (confidence < 60) {
            finalPred = null;
            finalPred.skipReason = 'HOLD (Standard Mode Low Conf)';
        }
    }
    
    // Color Only Focus 
    if(colorOnlyFocusToggle.checked && finalPred) {
        finalPred.predictedBS = 'SKIP';
    }

    return finalPred;
}
// --- END CORE V9.0 AWP LOGIC ---

function batchMergeTrain(arr){
  if(!arr || !arr.length) return;
  setStatus('Merging ' + arr.length + ' rounds...', false);

  const existingActuals = state.history.map(r => Number(r.Actual));
  const combined = existingActuals.concat(arr);

  // Train with all depths up to L9
  for(let idx = existingActuals.length; idx < combined.length; idx++){
    for(let i = 1; i <= MAX_PATTERN_DEPTH; i++){
        if(idx >= i){
            recordPattern(keyFromSeq(combined.slice(idx - i, idx)), combined[idx]);
        }
    }
  }

  // Calculate results for history
  for(let i = 0; i < arr.length; i++){
    const globalIndex = existingActuals.length + i;
    const rawPred = predictFromArray(combined, globalIndex);
    const actual = arr[i];
    const actualMap = mapDigit(actual);
    
    const last = state.history.length ? state.history[state.history.length - 1] : null;
    let bs_stage = last ? last.BS_Stage : 0;
    let color_stage = last ? last.Color_Stage : 0;
    
    // Apply V9.0 Final Prediction Filter
    const finalPred = getFinalPrediction(rawPred, bs_stage, color_stage);
    
    const isSkip = !finalPred;
    const predBS = isSkip ? 'SKIP' : finalPred.predictedBS;
    const predColor = isSkip ? 'SKIP' : finalPred.predictedColor;
    
    const bs_result = predBS === 'SKIP' ? 'SKIP' : (predBS === actualMap.BS ? 'Win' : 'Loss');
    const color_result = predColor === 'SKIP' ? 'SKIP' : (predColor === actualMap.Color ? 'Win' : 'Loss');

    if(bs_result === 'Win') bs_stage = 0;
    else if(bs_result === 'Loss') bs_stage = bs_stage + 1;

    if(color_result === 'Win') color_stage = 0;
    else if(color_result === 'Loss') color_stage = color_stage + 1;

    const newRound = {
      Round: state.history.length + 1, Actual: actual,
      Predicted_Digit: isSkip ? 'SKIP/HOLD' : (rawPred ? rawPred.predictedDigit : -1),
      Predicted_Color: predColor,
      Predicted_BS: predBS,
      Confidence: isSkip ? 0 : (rawPred ? rawPred.confidence : 0),
      BS_Result: bs_result, Color_Result: color_result, BS_Stage: bs_stage, Color_Stage: color_stage
    };

    state.history.push(newRound);
  }

  saveLocal();
  renderAll();
  setStatus('Merged ' + arr.length + ' rounds â€” patterns updated', true);
}


// --- DYNAMIC STAGE COLORING LOGIC (Unchanged) ---
function getStageClass(stage) {
    if (stage === 0 || stage === 1) return 'stage-0 stage-1';
    if (stage === 2 || stage === 3) return 'stage-2 stage-3';
    if (stage >= 4) return 'stage-4-plus';
    return '';
}

// ---------- UI render (Updated for V9.0 Logic) ----------
function renderAll(){
  totalRoundsEl.textContent = state.history.length;
  const stats = state.history.reduce((acc, r) => {
    if(r.BS_Result === 'Win') acc.bsWin++; else if(r.BS_Result === 'Loss') acc.bsLoss++;
    if(r.Color_Result === 'Win') acc.colWin++; else if(r.Color_Result === 'Loss') acc.colLoss++;
    return acc;
  }, { bsWin:0, bsLoss:0, colWin:0, colLoss:0 });
  document.getElementById('bsWL').textContent = stats.bsWin + ' / ' + stats.bsLoss;
  document.getElementById('colorWL').textContent = stats.colWin + ' / ' + stats.colLoss;
  
  const last = state.history.length ? state.history[state.history.length - 1] : null;
  const bsStage = last ? last.BS_Stage : 0;
  const colStage = last ? last.Color_Stage : 0;
  
  const bsStageEl = document.getElementById('bsStage');
  const colStageEl = document.getElementById('colStage');
  
  bsStageEl.textContent = bsStage;
  colStageEl.textContent = colStage;
  
  bsStageEl.className = 'val ' + getStageClass(bsStage);
  colStageEl.className = 'val ' + getStageClass(colStage);

  const rawPred = predictUsingMemory();
  const finalPred = getFinalPrediction(rawPred, bsStage, colStage); // V9.0 AWP Filter

  if(finalPred){
    predDigitEl.textContent = finalPred.predictedDigit;
    predColorEl.textContent = finalPred.predictedColor;
    predBSEl.textContent = finalPred.predictedBS;
    confFill.style.width = finalPred.confidence + '%';
    confText.textContent = 'Confidence: ' + finalPred.confidence + '%';
  } else {
    predDigitEl.textContent = 'HOLD';
    predColorEl.textContent = 'SKIP';
    predBSEl.textContent = 'SKIP';
    confFill.style.width = '8%';
    
    let reason = 'No strong pattern';
    if(rawPred && aggressiveAWPToggle.checked) {
        // Display actual reason for the hold in AWP mode
        const currentStage = Math.max(bsStage, colStage);
        if (currentStage === 2) reason = 'HOLD (AWP: Stage 2 Conf < 60)';
        else if (currentStage === 3) reason = 'HOLD (AWP: Stage 3 Conf < 50)';
        else if (currentStage >= 4) reason = 'HOLD (AWP: Recovery Low Conf)';
        else if (currentStage <= 1) reason = 'HOLD (AWP: Safe Low Conf)';
    }

    confText.textContent = reason;
  }

  historyList.innerHTML = '';
  const display = state.history.slice(-150).reverse();
  display.forEach(r=>{
    const div = document.createElement('div'); div.className = 'hist-item';
    const predDigit = (r.Predicted_Digit === -1 || r.Predicted_Digit === 'SKIP/HOLD') ? 'â€”' : r.Predicted_Digit;
    const predColor = r.Predicted_Color === 'SKIP' ? 'SKIP' : r.Predicted_Color;
    const predBS = r.Predicted_BS === 'SKIP' ? 'SKIP' : r.Predicted_BS;
    const colorResult = r.Color_Result === 'SKIP' ? 'SKIP' : r.Color_Result;
    const bsResult = r.BS_Result === 'SKIP' ? 'SKIP' : r.BS_Result;

    div.innerHTML = `<div class="h-round">${r.Round}</div>
      <div class="h-act">${r.Actual}</div>
      <div class="h-pred">${predDigit} â€¢ ${predColor} â€¢ ${predBS}</div>
      <div style="width:80px;text-align:right" class="${colorResult==='Win'?'success':colorResult==='Loss'?'fail':''}">${colorResult}</div>
      <div style="width:80px;text-align:right" class="${bsResult==='Win'?'success':bsResult==='Loss'?'fail':''}">${bsResult}</div>`;
    historyList.appendChild(div);
  });

  const keys = Object.keys(state.patterns);
  uniquePatternsEl.textContent = keys.length;
  const arr = keys.map(k=>({k, tot: state.patterns[k].total || 0, best: bestFromPattern(k)})).sort((a,b)=>b.tot-a.tot).slice(0,12);
  topPatternsEl.innerHTML = '';
  arr.forEach(p=>{
    const el = document.createElement('div'); el.className='small'; el.style.marginBottom='6px';
    const best = p.best ? `${p.best.digit} (${p.best.confidence}%)` : 'â€”';
    el.innerHTML = `<strong style="color:var(--neon)">${p.k}</strong> â†’ total:${p.tot} â€¢ best: ${best}`;
    topPatternsEl.appendChild(el);
  });
}

// ---------- Events (Updated for V9.0 Logic) ----------
runTrainBtn.addEventListener('click', ()=>{
  const txt = importArea.value.trim();
  if(!txt){ alert('Paste data first'); return; }
  const arr = parseSequenceText(txt);
  if(arr.length < PATTERN_LEN + 1){ alert(`Not enough valid numbers (min ${PATTERN_LEN + 1})`); return; }
  setStatus('Batch merging data â€” this may take a moment...', false);
  setTimeout(()=>{
    try{
      batchMergeTrain(arr);
      saveRawDataToLocal();
      if(currentUser) saveCloud();
    } catch(e){ console.error('train error', e); setStatus('Training failed'); alert('Training failed: '+e.message); }
  }, 60);
});

// NEW EVENT LISTENERS FOR FILE IMPORT
importFileBtn.addEventListener('click', () => {
    importFileInput.click(); // Trigger hidden file input
});

importFileInput.addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        // Load file content into the paste box
        importArea.value = e.target.result;
        setStatus('File content loaded to paste box. Click "Run / Batch Merge Train" to start.', true);
        // Clear file input so the same file can be uploaded again if needed
        importFileInput.value = null;
    };
    reader.readAsText(file);
});


analyzeBtn.addEventListener('click', ()=>{
  const keys = Object.keys(state.patterns);
  if(!keys.length) return setStatus('No patterns in memory', true);
  const top = keys.map(k=>({k, tot: state.patterns[k].total})).sort((a,b)=>b.tot-a.tot).slice(0,10);
  const msg = top.map(t=>`${t.k} -> ${t.tot}`).join('\n');
  alert('Top patterns:\n' + msg);
});

enterBtn.addEventListener('click', ()=>{
  const input = manualInput.value.trim();
  if(input === '') { setStatus('No input'); manualInput.focus(); return; }
  const n = Number(input);
  if(isNaN(n) || n < 0 || n > 9){ alert('Enter valid number 0-9'); manualInput.value=''; manualInput.focus(); return; }

  const currentRaw = importArea.value.trim();
  const separator = currentRaw.includes(',') ? ',' : (currentRaw.length > 0 ? ' ' : '');
  let newValue = currentRaw;
  if (currentRaw.length > 0) newValue += separator;
  newValue += n;
  importArea.value = newValue;
  saveRawDataToLocal();

  try{
    const rawPred = predictUsingMemory();
    const actualMap = mapDigit(n);
    
    const last = state.history.length ? state.history[state.history.length - 1] : null;
    let bs_stage = last ? last.BS_Stage : 0;
    let color_stage = last ? last.Color_Stage : 0;

    // Apply V9.0 Final Prediction Filter
    const finalPred = getFinalPrediction(rawPred, bs_stage, color_stage);

    const isSkip = !finalPred;
    const predBS = isSkip ? 'SKIP' : finalPred.predictedBS;
    const predColor = isSkip ? 'SKIP' : finalPred.predictedColor;
    
    const bs_result = predBS === 'SKIP' ? 'SKIP' : (predBS === actualMap.BS ? 'Win' : 'Loss');
    const color_result = predColor === 'SKIP' ? 'SKIP' : (predColor === actualMap.Color ? 'Win' : 'Loss');

    if(bs_result === 'Win') bs_stage = 0;
    else if(bs_result === 'Loss') bs_stage = bs_stage + 1;

    if(color_result === 'Win') color_stage = 0;
    else if(color_result === 'Loss') color_stage = color_stage + 1;

    const newRound = {
      Round: state.history.length + 1, Actual: n,
      Predicted_Digit: isSkip ? 'SKIP/HOLD' : (rawPred ? rawPred.predictedDigit : -1),
      Predicted_Color: predColor,
      Predicted_BS: predBS,
      Confidence: isSkip ? 0 : (rawPred ? rawPred.confidence : 0),
      BS_Result: bs_result, Color_Result: color_result, BS_Stage: bs_stage, Color_Stage: color_stage
    };

    const len = state.history.length;
    // Record all pattern depths up to L9 for the new entry
    for(let i = 1; i <= MAX_PATTERN_DEPTH; i++){
        if(len >= i - 1) { // i-1 because we push the new round after
            const seq = state.history.slice(len - (i-1), len).map(r=>r.Actual);
            // Append current actual number to the sequence for recording
            if(seq.length === i - 1 && len + 1 >= i) {
                seq.push(n);
                // The key for pattern length i is the sequence of length i-1
                recordPattern(keyFromSeq(seq.slice(0, i - 1)), n);
            } else if (i === 1) {
                // Special case for L1
                recordPattern([], n);
            }
        }
    }
    
    // Correct way to record patterns with max depth
    for(let i = 1; i <= MAX_PATTERN_DEPTH; i++){
        if(len + 1 >= i){
            const seq = state.history.map(r=>r.Actual);
            seq.push(n);
            if(seq.length >= i){
                const pattern = seq.slice(seq.length - i - 1, seq.length - 1);
                if(pattern.length === i - 1) {
                    recordPattern(keyFromSeq(pattern), n);
                }
            }
        }
    }
    // Final check for recording:
    for(let i = 1; i <= MAX_PATTERN_DEPTH; i++){
        if(len >= i - 1){
            const startIndex = len - (i - 1);
            if(startIndex >= 0) {
                const pattern = state.history.slice(startIndex, len).map(r=>r.Actual);
                if(pattern.length === i - 1) {
                    recordPattern(keyFromSeq(pattern), n);
                }
            }
        }
    }

    state.history.push(newRound);
  } catch(e){ console.error(e); setStatus('Manual error'); }
  finally { 
    saveLocal(); 
    if(currentUser) saveCloud(); 
    renderAll(); 
    setStatus('Manual entry recorded & learning complete', true);
    
    manualInput.value = '';
    manualInput.focus();
  }
});

exportFullBtn.addEventListener('click', ()=>{
  if(!state.history.length){ alert('No history to export'); return; }
  const headers = ['Round','Actual','Predicted_Digit','Predicted_Color','Predicted_BS','Confidence','BS_Result','Color_Result','BS_Stage','Color_Stage'];
  const rows = [headers.join(',')];
  state.history.forEach(r => {
    const row = [r.Round,r.Actual,r.Predicted_Digit,r.Predicted_Color,r.Predicted_BS,r.Confidence,r.BS_Result,r.Color_Result,r.BS_Stage,r.Color_Stage];
    rows.push(row.map(v=> (v === -1 || v === 'SKIP/HOLD') ? 'SKIP/HOLD' : v).join(','));
  });
  const csv = rows.join('\n'); const blob = new Blob([csv], { type: 'text/csv' }); const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'saeed_v9_0_history_FULL.csv'; a.click(); URL.revokeObjectURL(url);
});

exportRawBtn.addEventListener('click', ()=>{
    const rawData = importArea.value.trim();
    if (!rawData) { alert('No raw data in the box to export!'); return; }
    const cleanedData = parseSequenceText(rawData).join(',');
    const blob = new Blob([cleanedData], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'saeed_v9_0_raw_data_backup.csv'; a.click(); URL.revokeObjectURL(url);
    setStatus('Raw data exported', true);
});

clearLocalBtn.addEventListener('click', ()=>{
  if(!confirm('Clear all local data (history, patterns, and raw data)?')) return;
  state = { history: [], patterns: {}, aggressiveAWP:false, colorOnlyFocus:false };
  localStorage.removeItem(LOCAL_KEY);
  localStorage.removeItem(PATTERNS_KEY_LARGE);
  localStorage.removeItem(HISTORY_KEY_LARGE);
  localStorage.removeItem(RAW_DATA_KEY);
  importArea.value = '';
  saveLocal();
  renderAll();
  setStatus('Local data cleared');
});
saveLocalBtn.addEventListener('click', ()=>{ saveLocal(); });
downloadHtmlBtn.addEventListener('click', ()=>{
  const blob = new Blob([document.documentElement.outerHTML], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'saeed_hybrid_predictor_v9_0_final.html'; a.click(); URL.revokeObjectURL(url);
});

// ---------- Cloud (Firestore - Unchanged Logic) ----------
async function saveCloud(){
  if(!currentUser || !db) return;
  try {
    const docRef = doc(db, 'users', currentUser.uid);
    // Cloud sync still saves full state for easy recovery/consistency
    await setDoc(docRef, { history: state.history, patterns: state.patterns, updatedAt: new Date().toISOString() });
    setStatus('Synced to cloud', true);
  } catch(e){ console.error('saveCloud', e); setStatus('Cloud save failed'); }
}
async function loadCloud(){
  if(!currentUser || !db) return;
  try {
    const docRef = doc(db, 'users', currentUser.uid);
    const snap = await getDoc(docRef);
    if(snap.exists()){
      const data = snap.data();
      if(data.patterns && data.history){
        const toggles = { aggressiveAWP: state.aggressiveAWP, colorOnlyFocus: state.colorOnlyFocus };
        state.patterns = data.patterns;
        state.history = data.history;
        state.aggressiveAWP = toggles.aggressiveAWP;
        state.colorOnlyFocus = toggles.colorOnlyFocus;
        saveLocal();
        renderAll();
        setStatus('Loaded from cloud', true);
      }
    } else { setStatus('No cloud data (first time)'); }
  } catch(e){ console.error('loadCloud', e); setStatus('Cloud load failed'); }
}
function subscribeCloudLive(){
  if(!currentUser || !db) return;
  const docRef = doc(db, 'users', currentUser.uid);
  if(unsubscribeCloud) unsubscribeCloud();
  unsubscribeCloud = onSnapshot(docRef, snap => {
    if(snap.exists()){
      const data = snap.data();
      if(data.patterns && data.history){
        const toggles = { aggressiveAWP: state.aggressiveAWP, colorOnlyFocus: state.colorOnlyFocus };
        state.patterns = data.patterns;
        state.history = data.history;
        state.aggressiveAWP = toggles.aggressiveAWP;
        state.colorOnlyFocus = toggles.colorOnlyFocus;
        saveLocal(); renderAll(); setStatus('Cloud update received');
      }
    }
  }, e => { console.error('snapshot err', e); });
}

// Auth UI (Unchanged)
googleSignInBtn.addEventListener('click', async ()=>{
  if(!auth){ alert('Firebase not initialized'); return; }
  if(!currentUser){
    try{ 
      const res = await signInWithPopup(auth, provider); 
      currentUser = res.user; 
      setupUserUI(); 
      await loadCloud(); 
      subscribeCloudLive(); 
    }
    catch(e){ 
      console.error('signin error:', e);
      if(e.code === 'auth/popup-closed-by-user' || e.code === 'auth/cancelled-popup-request' || e.message.includes('popup')){
           alert('Sign-in failed: Popup window was blocked. Please ensure your browser\'s Pop-up blocker is OFF for this file.');
      } else {
           alert('Sign-in failed: Server or API error. (Check Firebase Auth keys/Project settings)');
      }
    }
  } else {
    try{ await signOut(auth); currentUser = null; if(unsubscribeCloud) unsubscribeCloud(); unsubscribeCloud = null; setupUserUI(); setStatus('Signed out'); }
    catch(e){ console.error('signout', e); }
  }
});

if(auth){
  onAuthStateChanged(auth, user => {
    if(user){ currentUser = user; setupUserUI(); loadCloud(); subscribeCloudLive(); } else { currentUser = null; setupUserUI(); }
  });
}

function setupUserUI(){
  if(currentUser){
    userArea.textContent = currentUser.displayName || currentUser.email;
    googleSignInBtn.textContent = 'Sign out';
  } else {
    userArea.textContent = 'Not signed in';
    googleSignInBtn.textContent = 'Sign in with Google';
  }
}

// initial load
loadLocal();
setupUserUI();
setTimeout(()=>{ renderAll(); manualInput.focus(); }, 80);

</script>
</body>
</html>
