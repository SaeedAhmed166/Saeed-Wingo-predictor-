<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ðŸ”¥ Saeed Wingo AI Predictor v8.1â€”File Import & Stable Core (FIXED)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
<style>
/* --- Core Modern Glow UI --- */
:root{
  --bg:#050507; --fg:#e6fffb; --muted:#9fdedc; --neon:#38e6ff; --green:#00f59b; --danger:#ff6b6b;
  --warn:#ffc107;
}
*{box-sizing:border-box;font-family:Inter,system-ui,Arial,Helvetica,sans-serif}
html,body{height:100%;margin:0;background:radial-gradient(circle at 20% 10%, #071018 0%, #020204 50%, #000 100%);color:var(--fg)}
.container{max-width:1100px;margin:18px auto;padding:16px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03)}
.header{display:flex;justify-content:space-between;align-items:center;gap:12px}
.title{font-size:1.4rem;font-weight:800;color:var(--neon); text-shadow: 0 0 8px rgba(56, 230, 255, 0.4);}
.subtitle{font-size:0.86rem;color:var(--muted)}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
.btn{padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);background:rgba(0,0,0,0.5);color:var(--fg);font-weight:700;cursor:pointer;transition:all 0.2s;}
.btn:hover{background:rgba(255,255,255,0.1);}
.btn.primary{background:linear-gradient(90deg,var(--neon),var(--green));color:#001b1a;border:none}
.btn.primary:hover{box-shadow: 0 0 10px rgba(56, 230, 255, 0.6);}
.btn.warn{background:linear-gradient(90deg,#ff61c7,var(--danger));color:white;border:none}
.btn.accent{background:rgba(56, 230, 255, 0.2); color: var(--neon); border-color: var(--neon);} /* Import File button style */
.grid{display:grid;grid-template-columns:2fr 1fr;gap:14px;margin-top:14px}
.panel{padding:12px;border-radius:10px;background:rgba(0,0,0,0.45);border:1px solid rgba(255,255,255,0.02)}
textarea{width:100%;min-height:120px;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:rgba(0,0,0,0.55);color:var(--fg);resize:vertical}
.input-row{display:flex;gap:8px;align-items:center;margin-top:8px}
.input-row input[type=number]{padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:var(--fg);width:140px;text-align:center}
.small{font-size:0.86rem;color:var(--muted)}
.stat-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px}
.stat{padding:8px;border-radius:8px;background:rgba(0,0,0,0.45);border:1px solid rgba(255,255,255,0.02);font-weight:700;color:var(--muted)}
.history{max-height:480px;overflow-y:auto;margin-top:10px;border-top:1px dashed rgba(255,255,255,0.02);padding-top:8px}
.hist-item{display:flex;gap:8px;align-items:center;padding:8px;border-bottom:1px dashed rgba(255,255,255,0.02)}
.h-round{width:48px;color:var(--neon);font-weight:800}
.h-act{width:40px}
.h-pred{flex:1;color:var(--muted)}
.footer-note{margin-top:8px;color:var(--muted);font-size:0.86rem}
.toggle{display:flex;align-items:center;gap:8px}
/* --- Custom Colors for Results & Stages --- */
.bad{color:#ff61c7}
.success{color:var(--green);font-weight:700;}
.fail{color:var(--danger);font-weight:700;}
.stage-0, .stage-1{color:var(--green); font-weight: 800;}
.stage-2, .stage-3{color:var(--neon); font-weight: 800;}
.stage-4-plus{color:var(--danger); font-weight: 800; text-shadow: 0 0 5px rgba(255, 107, 107, 0.4);}

@media (max-width:980px){ .grid{grid-template-columns:1fr} .input-row{flex-direction:column;align-items:stretch} }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div>
      <div class="title">ðŸ”¥ Saeed Wingo AI Predictor v8.1â€”File Import & Stable Core (FIXED)</div>
      <div class="subtitle">L5 Hybrid Core Â· File Import Added Â· Round Numbers Removed from History</div>
    </div>
    <div class="controls">
      <div id="userArea" class="small">Not signed in</div>
      <button id="googleSignIn" class="btn primary">Sign in with Google</button>
      <button id="downloadHtml" class="btn">Download HTML</button>
      <button id="exportRawBtn" class="btn warn">Export Raw</button>
      <button id="exportFullBtn" class="btn">Export Full</button>
      <button id="clearLocal" class="btn warn">Clear All</button>
      <button id="saveLocal" class="btn">Save Local</button>
    </div>
  </div>

  <div class="grid">
    <div>
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:800">Live Training & Batch Import</div>
          <div class="small">Core Patterns: <span id="patternLenDisplay">L1â€“L5 Hybrid</span></div>
        </div>

        <p class="small footer-note">Paste comma/space/newline separated numbers (0â€“9) or **Import File** below.</p>
        <textarea id="importArea" placeholder="Paste sequence here (commas, spaces or newlines allowed)"></textarea>
        <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
          <button id="runTrain" class="btn primary">Run / Merge Train</button>
          <button id="importFileBtn" class="btn accent">Import File</button>
          <button id="analyzeBtn" class="btn">Analyze Memory</button>
          <div id="status" class="small" style="margin-left:8px">Status: idle</div>
        </div>

        <div class="panel" style="margin-top:12px">
          <div style="display:flex;gap:10px;align-items:center">
            <div style="flex:1">
              <div class="small">Predicted Digit</div>
              <div id="predDigit" style="font-size:1.4rem;font-weight:800">-</div>
            </div>
            <div style="flex:1">
              <div class="small">Color</div>
              <div id="predColor" style="font-size:1.1rem;font-weight:800">-</div>
            </div>
            <div style="flex:1">
              <div class="small">B/S</div>
              <div id="predBS" style="font-size:1.1rem;font-weight:800">-</div>
            </div>
            <div style="flex:2">
              <div class="small">Confidence</div>
              <div style="height:12px;background:#222;border-radius:8px;overflow:hidden"><div id="confFill" style="height:12px;width:0%;background:linear-gradient(90deg,var(--neon),var(--green));transition:width:300ms"></div></div>
              <div id="confText" class="small footer-note">â€”</div>
            </div>
          </div>

          <div style="margin-top:12px;display:flex;justify-content:space-between;align-items:center;gap:12px">
            <div style="flex:1">
              <div class="input-row">
                <input id="manualInput" type="number" min="0" max="9" placeholder="Enter actual number (0-9)">
                <button id="enterBtn" class="btn primary">Submit</button>
              </div>
              <div class="small footer-note">**Learning is automatic** upon submit. Input is auto-cleared.</div>
            </div>

            <div style="width:300px">
              <div style="display:flex;gap:8px;align-items:center">
                <label class="toggle"><input type="checkbox" id="under3"> <span class="small">**Ultra-Stable Lock** (Conf &lt; 60% = HOLD)</span></label>
              </div>
              <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
                <label class="toggle"><input type="checkbox" id="under5"> <span class="small">Loss Stage Recovery (Wait after 4)</span></label>
              </div>
              <div class="note small footer-note">Use Ultra-Stable Lock to enforce **Minimum Loss Stages** strategy.</div>
            </div>
          </div>
        </div>

      </div>

      <div class="panel" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:800">Pattern Memory Overview</div>
          <div class="small">Unique L1-L5 Patterns: <span id="uniquePatterns">0</span></div>
        </div>
        <div id="topPatterns" style="margin-top:8px" class="small"></div>
      </div>
    </div>

    <div>
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:800">Stats & Recent History (Stage Focus)</div>
          <div class="small">Rounds: <span id="totalRounds">0</span></div>
        </div>

        <div class="stat-grid">
          <div class="stat">Big/Small W/L <span class="val" id="bsWL">0 / 0</span></div>
          <div class="stat">Color W/L <span class="val" id="colorWL">0 / 0</span></div>
          <div class="stat">BS Loss Stage <span class="val" id="bsStage">0</span></div>
          <div class="stat">Color Loss Stage <span class="val" id="colStage">0</span></div>
        </div>

        <div class="history" id="historyList"></div>
        <div class="footer-note">Last 150 rounds shown. Use Export Full for complete data.</div>
      </div>
    </div>
  </div>
</div>

<script type="module">
/* --- Saeed Wingo AI Predictor v8.1 FIXED ---
   1. FIXED: Training failed: Cannot set properties of null (setting 'textContent') error.
   2. IMPROVED: Pattern learning to L1, L2, L3, L4, L5 Hybrid Core.
   3. UPDATED: UI to match v8.1 features (Labels, Toggles, Import File).
*/

// --- Firebase Configuration (Using the correct keys from v7.2) ---
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
import { getFirestore, doc, setDoc, getDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

const firebaseConfig = {
  // --- USER'S CORRECT KEYS ---
  apiKey: "AIzaSyA6uJKnUfJqS1T_GbSlUq8eChxJBdZtwVQ",
  authDomain: "saeed-hybrid-predictor-672ed.firebaseapp.com",
  projectId: "saeed-hybrid-predictor-672ed",
  storageBucket: "saeed-hybrid-predictor-672ed.firebasestorage.app",
  messagingSenderId: "968218548586",
  appId: "1:968218548586:web:c51840d9c49225f885ad13",
  measurementId: "G-QBK0HPDDBE"
  // --- END OF USER'S CORRECT KEYS ---
};

let app = null;
try { app = initializeApp(firebaseConfig); } catch(e){ console.warn("Firebase init failed:", e.message); }

const auth = app ? getAuth(app) : null;
const provider = new GoogleAuthProvider();
const db = app ? getFirestore(app) : null;

// ---------- DOM & State ----------
const importArea = document.getElementById('importArea');
const runTrainBtn = document.getElementById('runTrain');
const analyzeBtn = document.getElementById('analyzeBtn');
const statusEl = document.getElementById('status');
const predDigitEl = document.getElementById('predDigit');
const predColorEl = document.getElementById('predColor');
const predBSEl = document.getElementById('predBS');
const confFill = document.getElementById('confFill');
const confText = document.getElementById('confText');
const historyList = document.getElementById('historyList');
const totalRoundsEl = document.getElementById('totalRounds');
const uniquePatternsEl = document.getElementById('uniquePatterns');
const topPatternsEl = document.getElementById('topPatterns');
const enterBtn = document.getElementById('enterBtn');
const manualInput = document.getElementById('manualInput');
const under3Toggle = document.getElementById('under3');
const under5Toggle = document.getElementById('under5');
const googleSignInBtn = document.getElementById('googleSignIn');
const userArea = document.getElementById('userArea');
const saveLocalBtn = document.getElementById('saveLocal');
const exportFullBtn = document.getElementById('exportFullBtn');
const exportRawBtn = document.getElementById('exportRawBtn');
const clearLocalBtn = document.getElementById('clearLocal');
const downloadHtmlBtn = document.getElementById('downloadHtml');
const importFileBtn = document.getElementById('importFileBtn'); // Added for v8.1 UI

const PATTERN_LEN = 3; // Base pattern length is 3, but logic now handles 1-5
const LOCAL_KEY = 'saeed_hybrid_v8_1_state'; // Updated key
const RAW_DATA_KEY = 'saeed_hybrid_v8_1_raw_data'; // Updated key
const PATTERNS_KEY_LARGE = 'saeed_patterns_v8_1_large'; // Updated key
const HISTORY_KEY_LARGE = 'saeed_history_v8_1_large'; // Updated key

let state = { history: [], patterns: {}, under3: false, under5: false };
let currentUser = null;
let unsubscribeCloud = null;

// ---------- Helpers (MODIFIED saveLocal/loadLocal) ----------
function setStatus(txt, ok=false){ statusEl.textContent = 'Status: ' + txt; statusEl.style.color = ok ? 'var(--green)' : ''; }

// --- ROBUST saveLocal to handle QuotaExceededError ---
function saveLocal(){ 
    // Essential settings sirf is key mein save honge
    const essentialState = { 
        under3: under3Toggle.checked, 
        under5: under5Toggle.checked,
    };
    
    // Large data ko stringify karke alag keys mein save karne ki koshish
    const patternsToSave = JSON.stringify(state.patterns);
    const historyToSave = JSON.stringify(state.history);

    try{ 
        // 1. Save small essential settings first
        localStorage.setItem(LOCAL_KEY, JSON.stringify(essentialState)); 
        
        // 2. Try to save large patterns memory
        localStorage.setItem(PATTERNS_KEY_LARGE, patternsToSave);
        
        // 3. Try to save history
        localStorage.setItem(HISTORY_KEY_LARGE, historyToSave);

        setStatus('Saved locally (Settings, Patterns, History)', true);
    }catch(e){
        if (e.name === 'QuotaExceededError' || e.code === 22) {
            setStatus('âš ï¸ Local Save FAILED: Memory is TOO BIG! Use Cloud Sync!', false);
            console.error("Local Storage Quota Exceeded. Patterns/History too large. Use Cloud.", e);
        } else {
            console.error(e); 
            setStatus('Local save failed', false);
        }
    } 
}

// --- ROBUST loadLocal to handle split data ---
function loadLocal(){ 
    // 1. Load Essential Settings
    const s = localStorage.getItem(LOCAL_KEY); 
    if(s){ 
        try{ 
            const d = JSON.parse(s); 
            state.under3 = !!d.under3; 
            state.under5 = !!d.under5; 
        }catch(e){console.error('parse local', e);} 
    } 

    // 2. Load Patterns and History from separate large keys
    const rawPatterns = localStorage.getItem(PATTERNS_KEY_LARGE);
    const rawHistory = localStorage.getItem(HISTORY_KEY_LARGE);
    
    if (rawPatterns) {
        try { state.patterns = JSON.parse(rawPatterns); } catch(e) { console.error("Patterns load failed", e); }
    }
    if (rawHistory) {
        try { state.history = JSON.parse(rawHistory); } catch(e) { console.error("History load failed", e); }
    }

    under3Toggle.checked = !!state.under3; 
    under5Toggle.checked = !!state.under5; 

    // 3. Load Raw Data
    const rawData = localStorage.getItem(RAW_DATA_KEY);
    if (rawData) {
        importArea.value = rawData;
        setStatus('Raw data loaded to box', true);
    }
    renderAll(); 
}
function saveRawDataToLocal(){
    try{ localStorage.setItem(RAW_DATA_KEY, importArea.value.trim()); } catch(e){ console.error('Raw data save failed', e); }
}

function keyFromSeq(seq){ return seq.join('-'); }
function recordPattern(key,next){
  if(!state.patterns[key]) state.patterns[key] = { counts: {}, total: 0 };
  const p = state.patterns[key];
  p.counts[next] = (p.counts[next] || 0) + 1;
  p.total += 1;
}
function bestFromPattern(key){
  const p = state.patterns[key]; if(!p) return null;
  let best = null; for(const [d,c] of Object.entries(p.counts)) if(!best || c > best.count) best = { digit: Number(d), count: c };
  if(!best) return null;
  const conf = Math.round((best.count / p.total) * 100);
  return { digit: best.digit, count: best.count, total: p.total, confidence: conf };
}

function mapDigit(d){
  d = Number(d);
  const map = {
    0:{Color:'Red', BS:'Small'}, 1:{Color:'Green', BS:'Small'}, 
    2:{Color:'Red', BS:'Small'}, 3:{Color:'Green', BS:'Small'}, 
    4:{Color:'Red', BS:'Small'}, 5:{Color:'Green', BS:'Big'}, 
    6:{Color:'Red', BS:'Big'}, 7:{Color:'Green', BS:'Big'}, 
    8:{Color:'Red', BS:'Big'}, 9:{Color:'Green', BS:'Big'}
  };
  return map[d] || {Color:'N/A', BS:'N/A'};
}

function parseSequenceText(text){
  if(!text) return [];
  // Also handle newlines for easier import
  const parts = text.split(/[\s,]+/); 
  const nums = parts.map(s=>s.trim()).filter(s=>s.length>0).map(s=>Number(s)).filter(n=>!isNaN(n) && n>=0 && n<=9);
  return nums;
}

// Predicts using L1, L2, L3, L4, L5 patterns
function weightedPrediction(lookbacks){
  const candidates = {}; let hasPattern = false;
  
  // Use a weighted approach for L1-L5 patterns
  for(let i=0;i<lookbacks.length;i++){
    const seq = lookbacks[i], key = keyFromSeq(seq), best = bestFromPattern(key);
    if(!best) continue;
    hasPattern = true;
    
    // Assign higher weight to longer patterns
    // L5=5, L4=4, L3=3, L2=2, L1=1
    const weight = seq.length; 
    
    const d = best.digit, score = best.confidence * weight;
    if(!candidates[d]) candidates[d] = { score: 0, weightSum: 0 };
    candidates[d].score += score; candidates[d].weightSum += weight;
  }
  if(!hasPattern) return null;
  let chosen = null, chosenScore = 0;
  for(const [d,info] of Object.entries(candidates)){
    if(!chosen || info.score > chosenScore){ chosen = Number(d); chosenScore = info.score; }
  }
  const totalWeights = Object.values(candidates).reduce((s,i)=>s + i.weightSum,0) || 1;
  let conf = Math.round((chosenScore / (100 * totalWeights)) * 100);
  conf = Math.min(100, Math.max(5, conf));
  const mapped = mapDigit(chosen);
  return { predictedDigit: chosen, predictedColor: mapped.Color, predictedBS: mapped.BS, confidence: conf };
}

function predictFromArray(arr, index){
  if(index < 1) return null;
  const lookbacks = [];
  if(index >= 5) lookbacks.push(arr.slice(index - 5, index)); // L5
  if(index >= 4) lookbacks.push(arr.slice(index - 4, index)); // L4
  if(index >= 3) lookbacks.push(arr.slice(index - 3, index)); // L3
  if(index >= 2) lookbacks.push(arr.slice(index - 2, index)); // L2
  if(index >= 1) lookbacks.push(arr.slice(index - 1, index)); // L1
  return weightedPrediction(lookbacks);
}

function predictUsingMemory(){
  const h = state.history;
  if(!h || h.length < 1) return null;
  const lookbacks = [];
  if(h.length >= 5) lookbacks.push(h.slice(-5).map(r=>r.Actual)); // L5
  if(h.length >= 4) lookbacks.push(h.slice(-4).map(r=>r.Actual)); // L4
  if(h.length >= 3) lookbacks.push(h.slice(-3).map(r=>r.Actual)); // L3
  if(h.length >= 2) lookbacks.push(h.slice(-2).map(r=>r.Actual)); // L2
  if(h.length >= 1) lookbacks.push([h[h.length - 1].Actual]); // L1
  return weightedPrediction(lookbacks);
}

function batchMergeTrain(arr){
  if(!arr || !arr.length) return;
  setStatus('Merging ' + arr.length + ' rounds...', false);

  const existingActuals = state.history.map(r => Number(r.Actual));
  const combined = existingActuals.concat(arr);

  for(let idx = existingActuals.length; idx < combined.length; idx++){
    const next = combined[idx];
    
    // L1 pattern (previous 1 digit)
    if(idx >= 1) {
        recordPattern(combined.slice(idx - 1, idx).join('-'), next);
    }
    // L2 pattern (previous 2 digits)
    if(idx >= 2) {
        recordPattern(combined.slice(idx - 2, idx).join('-'), next);
    }
    // L3 pattern
    if(idx >= 3){ 
        recordPattern(combined.slice(idx - 3, idx).join('-'), next);
    }
    // L4 pattern
    if(idx >= 4) {
        recordPattern(combined.slice(idx - 4, idx).join('-'), next);
    }
    // L5 pattern
    if(idx >= 5) {
        recordPattern(combined.slice(idx - 5, idx).join('-'), next);
    }
  }

  for(let i = 0; i < arr.length; i++){
    const globalIndex = existingActuals.length + i;
    const pred = predictFromArray(combined, globalIndex);
    const actual = arr[i];
    const actualMap = mapDigit(actual);
    const last = state.history.length ? state.history[state.history.length - 1] : null;
    let bs_stage = last ? last.BS_Stage : 0;
    let color_stage = last ? last.Color_Stage : 0;
    const isSkip = !pred || (under3Toggle.checked && pred.confidence < 60);
    const bs_result = isSkip ? 'SKIP' : (pred.predictedBS === actualMap.BS ? 'Win' : 'Loss');
    const color_result = isSkip ? 'SKIP' : (pred.predictedColor === actualMap.Color ? 'Win' : 'Loss');

    // SKIP should NOT reset loss streak counters
    if(bs_result === 'Win') bs_stage = 0;
    else if(bs_result === 'Loss') bs_stage = bs_stage + 1;

    if(color_result === 'Win') color_stage = 0;
    else if(color_result === 'Loss') color_stage = color_stage + 1;

    const newRound = {
      Round: state.history.length + 1, Actual: actual,
      Predicted_Digit: isSkip ? 'SKIP/HOLD' : (pred ? pred.predictedDigit : -1),
      Predicted_Color: isSkip ? 'SKIP' : (pred ? pred.predictedColor : 'SKIP'),
      Predicted_BS: isSkip ? 'SKIP' : (pred ? pred.predictedBS : 'SKIP'),
      Confidence: isSkip ? 0 : (pred ? pred.confidence : 0),
      BS_Result: bs_result, Color_Result: color_result, BS_Stage: bs_stage, Color_Stage: color_stage
    };

    state.history.push(newRound);
  }

  saveLocal();
  renderAll();
  setStatus('Merged ' + arr.length + ' rounds â€” patterns updated', true);
}


// --- DYNAMIC STAGE COLORING LOGIC (Unchanged) ---
function getStageClass(stage) {
    if (stage === 0 || stage === 1) return 'stage-0 stage-1';
    if (stage === 2 || stage === 3) return 'stage-2 stage-3';
    if (stage >= 4) return 'stage-4-plus';
    return '';
}

// ---------- UI render (Fixed/Updated) ----------
function renderAll(){
  // V8.1 Bug Fix is here: totalRoundsEl should not be null.
  if(totalRoundsEl) totalRoundsEl.textContent = state.history.length;
  
  const stats = state.history.reduce((acc, r) => {
    if(r.BS_Result === 'Win') acc.bsWin++; else if(r.BS_Result === 'Loss') acc.bsLoss++;
    if(r.Color_Result === 'Win') acc.colWin++; else if(r.Color_Result === 'Loss') acc.colLoss++;
    return acc;
  }, { bsWin:0, bsLoss:0, colWin:0, colLoss:0 });
  document.getElementById('bsWL').textContent = stats.bsWin + ' / ' + stats.bsLoss;
  document.getElementById('colorWL').textContent = stats.colWin + ' / ' + stats.colLoss;
  
  const last = state.history.length ? state.history[state.history.length - 1] : null;
  const bsStage = last ? last.BS_Stage : 0;
  const colStage = last ? last.Color_Stage : 0;
  
  const bsStageEl = document.getElementById('bsStage');
  const colStageEl = document.getElementById('colStage');
  
  bsStageEl.textContent = bsStage;
  colStageEl.textContent = colStage;
  
  bsStageEl.className = 'val ' + getStageClass(bsStage);
  colStageEl.className = 'val ' + getStageClass(colStage);

  const rawPred = predictUsingMemory();
  let toShow = rawPred;
  if(under3Toggle.checked){
    if(!rawPred || rawPred.confidence < 60) toShow = null;
  }
  if(toShow){
    predDigitEl.textContent = toShow.predictedDigit;
    predColorEl.textContent = toShow.predictedColor;
    predBSEl.textContent = toShow.predictedBS;
    confFill.style.width = toShow.confidence + '%';
    confText.textContent = 'Confidence: ' + toShow.confidence + '%';
  } else {
    predDigitEl.textContent = 'HOLD';
    predColorEl.textContent = 'SKIP';
    predBSEl.textContent = 'SKIP';
    confFill.style.width = '8%';
    confText.textContent = under3Toggle.checked ? 'HOLD (Conf < 60%)' : 'No strong pattern';
  }

  historyList.innerHTML = '';
  const display = state.history.slice(-150).reverse();
  display.forEach(r=>{
    const div = document.createElement('div'); div.className = 'hist-item';
    const predDigit = (r.Predicted_Digit === -1 || r.Predicted_Digit === 'SKIP/HOLD') ? 'â€”' : r.Predicted_Digit;
    const predColor = r.Predicted_Color === 'SKIP' ? 'SKIP' : r.Predicted_Color;
    const predBS = r.Predicted_BS === 'SKIP' ? 'SKIP' : r.Predicted_BS;
    const colorResult = r.Color_Result === 'SKIP' ? 'SKIP' : r.Color_Result;
    const bsResult = r.BS_Result === 'SKIP' ? 'SKIP' : r.BS_Result;

    // V8.1: Removed Round Number from History for a cleaner look
    // div.innerHTML = `<div class="h-round">${r.Round}</div>...`
    div.innerHTML = `<div class="h-act">${r.Actual}</div>
      <div class="h-pred">${predDigit} â€¢ ${predColor} â€¢ ${predBS}</div>
      <div style="width:80px;text-align:right" class="${colorResult==='Win'?'success':colorResult==='Loss'?'fail':''}">${colorResult}</div>
      <div style="width:80px;text-align:right" class="${bsResult==='Win'?'success':bsResult==='Loss'?'fail':''}">${bsResult}</div>`;
    historyList.appendChild(div);
  });

  const keys = Object.keys(state.patterns);
  uniquePatternsEl.textContent = keys.length;
  // Sort by total for L1 patterns first, then other patterns
  const arr = keys.map(k=>({k, tot: state.patterns[k].total || 0, best: bestFromPattern(k)})).sort((a,b)=>b.tot-a.tot).slice(0,12);
  topPatternsEl.innerHTML = '';
  arr.forEach(p=>{
    const el = document.createElement('div'); el.className='small'; el.style.marginBottom='6px';
    const best = p.best ? `${p.best.digit} (${p.best.confidence}%)` : 'â€”';
    el.innerHTML = `<strong style="color:var(--neon)">${p.k}</strong> â†’ total:${p.tot} â€¢ best: ${best}`;
    topPatternsEl.appendChild(el);
  });
}

// ---------- Events (Updated) ----------
runTrainBtn.addEventListener('click', ()=>{
  const txt = importArea.value.trim();
  if(!txt){ alert('Paste data first'); return; }
  const arr = parseSequenceText(txt);
  if(arr.length < 1){ alert(`Not enough valid numbers (min 1)`); return; }
  setStatus('Batch merging data â€” this may take a moment...', false);
  setTimeout(()=>{
    try{
      batchMergeTrain(arr);
      saveRawDataToLocal();
      if(currentUser) saveCloud();
    } catch(e){ console.error('train error', e); setStatus('Training failed'); alert('Training failed: '+e.message); }
  }, 60);
});

// New Event for Import File (V8.1)
importFileBtn.addEventListener('click', () => {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.txt,.csv';
    fileInput.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(event) {
            importArea.value = event.target.result;
            setStatus('File content loaded. Click Run / Merge Train to process.', true);
        };
        reader.readAsText(file);
    };
    fileInput.click();
});

analyzeBtn.addEventListener('click', ()=>{
  const keys = Object.keys(state.patterns);
  if(!keys.length) return setStatus('No patterns in memory', true);
  const top = keys.map(k=>({k, tot: state.patterns[k].total})).sort((a,b)=>b.tot-a.tot).slice(0,10);
  const msg = top.map(t=>`${t.k} -> ${t.tot}`).join('\n');
  alert('Top patterns:\n' + msg);
});

enterBtn.addEventListener('click', ()=>{
  const input = manualInput.value.trim();
  if(input === '') { setStatus('No input'); manualInput.focus(); return; }
  const n = Number(input);
  if(isNaN(n) || n < 0 || n > 9){ alert('Enter valid number 0-9'); manualInput.value=''; manualInput.focus(); return; }

  const currentRaw = importArea.value.trim();
  const separator = currentRaw.includes(',') ? ',' : (currentRaw.length > 0 ? ' ' : '');
  let newValue = currentRaw;
  if (currentRaw.length > 0) newValue += separator;
  newValue += n;
  importArea.value = newValue;
  saveRawDataToLocal();

  try{
    const pred = predictUsingMemory();
    const actualMap = mapDigit(n);
    const last = state.history.length ? state.history[state.history.length - 1] : null;
    let bs_stage = last ? last.BS_Stage : 0;
    let color_stage = last ? last.Color_Stage : 0;
    const isSkip = !pred || (under3Toggle.checked && pred.confidence < 60);
    const bs_result = isSkip ? 'SKIP' : (pred.predictedBS === actualMap.BS ? 'Win' : 'Loss');
    const color_result = isSkip ? 'SKIP' : (pred.predictedColor === actualMap.Color ? 'Win' : 'Loss');

    if(bs_result === 'Win') bs_stage = 0;
    else if(bs_result === 'Loss') bs_stage = bs_stage + 1;

    if(color_result === 'Win') color_stage = 0;
    else if(color_result === 'Loss') color_stage = color_stage + 1;

    const newRound = {
      Round: state.history.length + 1, Actual: n,
      Predicted_Digit: isSkip ? 'SKIP/HOLD' : (pred ? pred.predictedDigit : -1),
      Predicted_Color: isSkip ? 'SKIP' : (pred ? pred.predictedColor : 'SKIP'),
      Predicted_BS: isSkip ? 'SKIP' : (pred ? pred.predictedBS : 'SKIP'),
      Confidence: isSkip ? 0 : (pred ? pred.confidence : 0),
      BS_Result: bs_result, Color_Result: color_result, BS_Stage: bs_stage, Color_Stage: color_stage
    };

    const len = state.history.length;
    // L1-L5 Pattern recording for manual entry
    const actuals = state.history.map(r=>r.Actual);
    if(len >= 1) recordPattern(actuals.slice(len - 1, len).join('-'), n);
    if(len >= 2) recordPattern(actuals.slice(len - 2, len).join('-'), n);
    if(len >= 3) recordPattern(actuals.slice(len - 3, len).join('-'), n);
    if(len >= 4) recordPattern(actuals.slice(len - 4, len).join('-'), n);
    if(len >= 5) recordPattern(actuals.slice(len - 5, len).join('-'), n);
    
    state.history.push(newRound);
    if(under5Toggle.checked && (bs_stage >= 4 || color_stage >= 4)) setStatus('Recovery mode active', true);
  } catch(e){ console.error(e); setStatus('Manual error'); }
  finally { 
    saveLocal(); 
    if(currentUser) saveCloud(); 
    renderAll(); 
    setStatus('Manual entry recorded & learning complete', true);
    
    manualInput.value = '';
    manualInput.focus();
  }
});

exportFullBtn.addEventListener('click', ()=>{
  if(!state.history.length){ alert('No history to export'); return; }
  const headers = ['Round','Actual','Predicted_Digit','Predicted_Color','Predicted_BS','Confidence','BS_Result','Color_Result','BS_Stage','Color_Stage'];
  const rows = [headers.join(',')];
  state.history.forEach(r => {
    const row = [r.Round,r.Actual,r.Predicted_Digit,r.Predicted_Color,r.Predicted_BS,r.Confidence,r.BS_Result,r.Color_Result,r.BS_Stage,r.Color_Stage];
    rows.push(row.map(v=> (v === -1 || v === 'SKIP/HOLD') ? 'SKIP/HOLD' : v).join(','));
  });
  const csv = rows.join('\n'); const blob = new Blob([csv], { type: 'text/csv' }); const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'saeed_v8_1_history_FULL.csv'; a.click(); URL.revokeObjectURL(url);
});

exportRawBtn.addEventListener('click', ()=>{
    const rawData = importArea.value.trim();
    if (!rawData) { alert('No raw data in the box to export!'); return; }
    const cleanedData = parseSequenceText(rawData).join(',');
    const blob = new Blob([cleanedData], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'saeed_v8_1_raw_data_backup.csv'; a.click(); URL.revokeObjectURL(url);
    setStatus('Raw data exported', true);
});

clearLocalBtn.addEventListener('click', ()=>{
  if(!confirm('Clear all local data (history, patterns, and raw data)?')) return;
  state = { history: [], patterns: {}, under3:false, under5:false };
  localStorage.removeItem(LOCAL_KEY);
  localStorage.removeItem(PATTERNS_KEY_LARGE);
  localStorage.removeItem(HISTORY_KEY_LARGE);
  localStorage.removeItem(RAW_DATA_KEY);
  importArea.value = '';
  saveLocal();
  renderAll();
  setStatus('Local data cleared');
});
saveLocalBtn.addEventListener('click', ()=>{ saveLocal(); });
downloadHtmlBtn.addEventListener('click', ()=>{
  const blob = new Blob([document.documentElement.outerHTML], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'saeed_hybrid_predictor_v8_1_FIXED.html'; a.click(); URL.revokeObjectURL(url);
});

// ---------- Cloud (Firestore - Unchanged Logic) ----------
async function saveCloud(){
  if(!currentUser || !db) return;
  try {
    const docRef = doc(db, 'users', currentUser.uid);
    // Cloud sync still saves full state for easy recovery/consistency
    await setDoc(docRef, { history: state.history, patterns: state.patterns, updatedAt: new Date().toISOString() });
    setStatus('Synced to cloud', true);
  } catch(e){ console.error('saveCloud', e); setStatus('Cloud save failed'); }
}
async function loadCloud(){
  if(!currentUser || !db) return;
  try {
    const docRef = doc(db, 'users', currentUser.uid);
    const snap = await getDoc(docRef);
    if(snap.exists()){
      const data = snap.data();
      if(data.patterns && data.history){
        const toggles = { under3: state.under3, under5: state.under5 };
        state.patterns = data.patterns;
        state.history = data.history;
        state.under3 = toggles.under3;
        state.under5 = toggles.under5;
        saveLocal();
        renderAll();
        setStatus('Loaded from cloud', true);
      }
    } else { setStatus('No cloud data (first time)'); }
  } catch(e){ console.error('loadCloud', e); setStatus('Cloud load failed'); }
}
function subscribeCloudLive(){
  if(!currentUser || !db) return;
  const docRef = doc(db, 'users', currentUser.uid);
  if(unsubscribeCloud) unsubscribeCloud();
  unsubscribeCloud = onSnapshot(docRef, snap => {
    if(snap.exists()){
      const data = snap.data();
      if(data.patterns && data.history){
        const toggles = { under3: state.under3, under5: state.under5 };
        state.patterns = data.patterns;
        state.history = data.history;
        state.under3 = toggles.under3;
        state.under5 = toggles.under5;
        saveLocal(); renderAll(); setStatus('Cloud update received');
      }
    }
  }, e => { console.error('snapshot err', e); });
}

// Auth UI (Updated Error Handling)
googleSignInBtn.addEventListener('click', async ()=>{
  if(!auth){ alert('Firebase not initialized'); return; }
  if(!currentUser){
    try{ 
      const res = await signInWithPopup(auth, provider); 
      currentUser = res.user; 
      setupUserUI(); 
      await loadCloud(); 
      subscribeCloudLive(); 
    }
    catch(e){ 
      console.error('signin error:', e);
      if(e.code === 'auth/popup-closed-by-user' || e.code === 'auth/cancelled-popup-request' || e.message.includes('popup')){
           alert('Sign-in failed: Popup window was blocked. Please ensure your browser\'s Pop-up blocker is OFF for this file.');
      } else {
           alert('Sign-in failed: Server or API error. (Check Firebase Auth keys/Project settings)');
      }
    }
  } else {
    try{ await signOut(auth); currentUser = null; if(unsubscribeCloud) unsubscribeCloud(); unsubscribeCloud = null; setupUserUI(); setStatus('Signed out'); }
    catch(e){ console.error('signout', e); }
  }
});

if(auth){
  onAuthStateChanged(auth, user => {
    if(user){ currentUser = user; setupUserUI(); loadCloud(); subscribeCloudLive(); } else { currentUser = null; setupUserUI(); }
  });
}

function setupUserUI(){
  if(currentUser){
    userArea.textContent = currentUser.displayName || currentUser.email;
    googleSignInBtn.textContent = 'Sign out';
  } else {
    userArea.textContent = 'Not signed in';
    googleSignInBtn.textContent = 'Sign in with Google';
  }
}

// initial load
loadLocal();
setupUserUI();
setTimeout(()=>{ renderAll(); manualInput.focus(); }, 80);

</script>
</body>
</html>
